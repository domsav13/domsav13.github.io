<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://domsav13.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://domsav13.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-01-14T19:49:37+00:00</updated><id>https://domsav13.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Building deep neural networks from scratch</title><link href="https://domsav13.github.io/blog/2025/mnist/" rel="alternate" type="text/html" title="Building deep neural networks from scratch"/><published>2025-12-18T15:12:00+00:00</published><updated>2025-12-18T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2025/mnist</id><content type="html" xml:base="https://domsav13.github.io/blog/2025/mnist/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Training of neural networks on the MNIST dataset]]></summary></entry><entry><title type="html">Controls for a 2D rocket</title><link href="https://domsav13.github.io/blog/2025/2drocket/" rel="alternate" type="text/html" title="Controls for a 2D rocket"/><published>2025-12-10T15:12:00+00:00</published><updated>2025-12-10T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2025/2drocket</id><content type="html" xml:base="https://domsav13.github.io/blog/2025/2drocket/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[LQG and model predictive control of a rocket for hovering, landing, and waypoint flight]]></summary></entry><entry><title type="html">Prosthetic leg</title><link href="https://domsav13.github.io/blog/2025/prosthesis/" rel="alternate" type="text/html" title="Prosthetic leg"/><published>2025-12-08T15:12:00+00:00</published><updated>2025-12-08T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2025/prosthesis</id><content type="html" xml:base="https://domsav13.github.io/blog/2025/prosthesis/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Requirement analysis and design of a knee prosthesis]]></summary></entry><entry><title type="html">Nonlinear Control of a DC Motor</title><link href="https://domsav13.github.io/blog/2025/nonlinear-controls/" rel="alternate" type="text/html" title="Nonlinear Control of a DC Motor"/><published>2025-11-25T15:12:00+00:00</published><updated>2025-11-25T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2025/nonlinear-controls</id><content type="html" xml:base="https://domsav13.github.io/blog/2025/nonlinear-controls/"><![CDATA[<h3 id="setup">Setup</h3> <p>The topic of study is the implementation of nonlinear control frameworks on the motor wheel system below. The true system dynamics are modeled separately as a Python simulator including several nonlinear effects such as stribeck friction, aerodynamic resistance, and more.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/motor-480.webp 480w,/assets/img/motor-800.webp 800w,/assets/img/motor-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/motor.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> A DC motor connected to a wheel, the electromechanical system for this analysis. </div> <p>A linear system can be formed for this system, but it is better represented with nonlinear, affine assumptions:</p> \[\dot{\omega}=f(\omega)+g(\omega)v_{in}\] <p>Two commonly used nonlinear methods include adaptive control and sliding mode control, which will be explored in further detail in the following sections. Adapative control makes the controller learn the dynamics in real time while maintaining stability whereas sliding mode control forces the states of a system to reach a predetermined sliding surface where the dynamics are designed to be stable and insensitive to disturbances.</p> <hr/> <h3 id="model-reference-adaptive-control">Model Reference Adaptive Control</h3> <p>Model reference adaptive control (MRAC) is an architecture in which a reference model representing ideal closed-loop behavior is chosen and the controller adjusts its own parameters in real time to force the plant to follow the reference. The following reference model will be used:</p> \[\dot{\omega}_m=-10\omega_m+10r\] <hr/> <h4 id="linear-mrac">Linear MRAC</h4> <p>There are two methods for performing MRAC: direct and indirect. In both cases, the controller must be designed to follow the reference model with the given linear dynamics that approximate the system:</p> \[\dot{\omega}=a \omega + bv_{in}\] <p>To achieve an equivalence for the reference model, the controller \(v_{in}^* = \frac{1}{b}\left(-(a+a_m)\omega+b_mr\right)\) is used:</p> \[\begin{aligned} \dot{\omega}&amp;=a \omega+bv_{in}^*\\ &amp;= a\omega + b\left(\frac{1}{b}(-(a+a_m)\omega+b_mr)\right)\\ &amp;= -a_m\omega+b_mr \end{aligned}\] <p>where \(a_m=b_m=10\) are chosen to match the previously established reference model \(\dot{\omega}_m\).</p> <hr/> <h5 id="direct-mrac">Direct MRAC</h5> <p>In direct MRAC, the controller gains are directly adapted with weights \(\hat{\alpha}\) and \(\hat{\beta}\) for \(v_{in} = -\hat{\alpha}\omega+\hat{\beta}r\) The dynamics become:</p> \[\begin{aligned} \dot{\omega}&amp;=a\omega+bv_{in}\\ &amp;= (a-b\hat{\alpha})\omega+b\hat{\beta}r\\ \dot{\omega}_m&amp;=-a_m\omega_m + b_mr \end{aligned}\] <p>where the unknown, ideal gains \((\alpha, \beta)\) match the model: \(a - b\alpha = -a_m\) and \(b\beta=b_m\)</p> <p>With the error terms \(\bar{\alpha}=\hat{\alpha}-\alpha\) and \(\bar{\beta}=\hat{\beta}-\beta\), the dynamics are expanded further to:</p> \[\begin{aligned} \dot{\omega}&amp;=a\omega+b(-\hat{\alpha}\omega+\hat{\beta}r)\\ &amp;= a\omega -b\omega(\bar{\alpha}+\alpha)+br(\bar{\beta}+\beta)\\ &amp;= (a-b\bar{\alpha}-b\alpha)\omega+(b\bar{\beta}+b\beta)r\\ &amp;= (-a_m-b\bar{\alpha})\omega+(b\bar{\beta}+b_m)r \end{aligned}\] <p>The Lyapunov function \(V(e,\bar{\alpha},\bar{\beta}) = \frac{1}{2}e^2+\frac{|b|}{2\gamma_1}\bar{\alpha}^2+\frac{|b|}{2\gamma_2}\bar{\beta}^2\) (where \(\gamma_1\) and \(\gamma_2\) are positive real values) is used with the adaptation laws \(\dot{\hat{\alpha}}=\gamma_1 \operatorname{sign}(b)\,\omega e\) and \(\dot{\hat{\beta}} = -\gamma_2 \operatorname{sign}(b)\, r e\) to guarantee negative definiteness in the tracking error, which ensures stability of the MRAC closed-loop system. Before showing that \(\dot{V} \le 0\) with this setup, the time derivative of the error term \(e = \omega - \omega_m\) is needed:</p> \[\begin{aligned} \dot{e}&amp;=\dot{\omega}-\dot{\omega}_m\\ &amp;= (-a_m-b\bar{\alpha})\omega+(b\bar{\beta}+b_m)r-(-a_m\omega_m+b_mr)\\ &amp;= -a_m(\omega-\omega_m)-b\bar{\alpha}\omega+b\bar{\beta}r\\ &amp;= -a_me-b\bar{\alpha}\omega+b\bar{\beta}r \end{aligned}\] <p>Using the aforementioned Lyapunov function, its derivative (proving negative definiteness) is:</p> \[\begin{aligned} \dot{V}(e,\bar{\alpha},\bar{\beta}) &amp;=e\dot{e}+|b|\operatorname{sign}(b)\omega e \bar{\alpha} - |b|\operatorname{sign}(b)r e \bar{\beta}\\ &amp;= e(-a_me-b\bar{\alpha}\omega+b\bar{\beta}r) +b\omega e\bar{\alpha}-br e\bar{\beta}\\ &amp;= -a_me^2 \end{aligned}\] <hr/> <h5 id="indirect-mrac">Indirect MRAC</h5> <p>In indirect MRAC, the parameters of the plant model are estimated and used to calculate the gains for the control law. With estimates \(\hat{a}\) and \(\hat{b}\) for ideal gains \(a\) and \(b\), the control law is established as:</p> \[v_{in}=\frac{1}{\hat{b}}\left(-(a_m+\hat{a})\omega+b_mr\right)\] <p>With the error terms \(\bar{a} = \hat{a} - a\) and \(\bar{b}=\hat{b}-b\), the dynamics are expanded to:</p> \[\begin{aligned} \dot{\omega}&amp;=a\omega+bv_{in}\\ &amp;= a\omega + \frac{b}{\hat{b}}\left(-(a_m+\hat{a})\omega+b_mr\right)\\ &amp;= a\omega + \left(1-\frac{\bar{b}}{\hat{b}}\right)\left(-(a_m+\hat{a})\omega+b_mr\right)\\ &amp;= a\omega-(a_m+\hat{a})\omega+b_mr+\frac{\bar{b}}{\hat{b}}(a_m+\hat{a})\omega-\frac{\bar{b}}{\hat{b}}b_mr\\ &amp;= -(a_m+\bar{a})\omega+b_mr+\frac{\bar{b}}{\hat{b}}\left((a_m+\hat{a})\omega-b_mr\right) \end{aligned}\] <p>With the adaptation laws \(\dot{\hat{a}} = \gamma_1\omega e\) and \(\dot{\hat{b}} = \gamma_2v_{in}e\) the time derivative of the Lyapunov function \(v(e,\bar{a},\bar{b}) = \frac{1}{2}e^2 + \frac{1}{2\gamma_1}\bar{a}^2+\frac{1}{2\gamma_2}\bar{b}^2\) will be negative definite, where \(\gamma_1\) and \(\gamma_2\) are positive real values. To show this, the time derivative of the error term \(e = \omega - \omega_m\) is needed again:</p> \[\begin{aligned} \dot{e}&amp;=\dot{\omega}-\dot{\omega}_m\\ &amp;= -a_m(\omega-\omega_m)-\bar{a}\omega+\frac{\bar{b}}{\hat{b}}\left((a_m+\hat{a})\omega-b_mr\right)\\ &amp;= -a_me-\bar{a}\omega+\frac{\bar{b}}{\hat{b}}\left((a_m+\hat{a})\omega-b_mr\right) \end{aligned}\] <p>Then, the derivative of the Lyapunov function (proving negative definiteness) is:</p> \[\begin{aligned} \dot{v}(e,\bar{a},\bar{b}) &amp;=e\dot{e}+\frac{1}{\gamma_1}\bar{a}\dot{\bar{a}}+\frac{1}{\gamma_2}\bar{b}\dot{\bar{b}}\\ &amp;= e\left(-a_me-\bar{a}\omega+\frac{\bar{b}}{\hat{b}}\left((a_m+\hat{a})\omega-b_mr\right)\right) +\bar{a}\omega e+\bar{b}e v_{in}\\ &amp;= -a_me^2 \end{aligned}\] <hr/> <h5 id="comparison">Comparison</h5> <p>For both direct and indirect MRAC, the controller successfully drive the reference model to follow commanded square, sine, and sawtooth inputs, but the physical plant struggles to match the model dynamics, most likely due to the very fast model parameters (\(a_m=b_m=10\)). The best tracking is obtained for centered sine waves, where the plant output roughly follows the model with some amplitude and phase, but square and sawtooth inputs produce larger tracking errors due to the sharper transitions in the signals. For offset inputs, the plant output appears to collapse to a constant. Because the offset introduces a constant component in the tracking error, the adaptation laws integrate this error, and the estimates ramp at the cost of responding poorly to the oscillatory component</p> <div class="row mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/direct-mrac-tracking-480.webp 480w,/assets/img/direct-mrac-tracking-800.webp 800w,/assets/img/direct-mrac-tracking-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/direct-mrac-tracking.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/indirect-mrac-tracking-480.webp 480w,/assets/img/indirect-mrac-tracking-800.webp 800w,/assets/img/indirect-mrac-tracking-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/indirect-mrac-tracking.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Comparison of tracking performances between direct and indirect MRAC for a variety of wave forms. </div> <hr/> <h4 id="nonlinear-mrac">Nonlinear MRAC</h4> <p>For the implemntation of nonlinear MRAC, it is assumed that the nonlinearities of the plant can be modeled by a radial basis function network such that:</p> \[f(\omega)=\alpha^T \sigma(\omega) \quad\quad\quad g(\omega)=\beta^T \sigma(\omega)\] <p>where \(\alpha, \beta \in \mathbb{R}^q\) are the weights for a network of radial basis functions (RBFs) \(\sigma(\omega) = \begin{bmatrix}\rho_1(\omega)&amp;...&amp;\rho_q(\omega)\end{bmatrix}^T\) where \(\rho_i(\omega)=\exp(-(\epsilon(\omega-\omega_i))^2)\) such that \(\omega_i\) is the center for each RBF and \(\epsilon\) is the width factor. The centers \(\omega_i\) are evenly spaced throughout the region of interests and \(\epsilon = \frac{d}{2}\) is initialized such that \(d\) is the distance between the centers. With this setup, and new weight estimates \(\hat{\alpha}\) and \(\hat{\beta}\), the resulting control law is:</p> \[u=v_{in}=\frac{1}{\hat{\beta}^T \sigma(\omega)}(-\hat{\alpha}^T\sigma(\omega)-a_m\omega+b_mr)\] <p>For stability, the Lyapunov function \(v(e,\bar{\alpha},\bar{\beta})=\frac{1}{2}e^2+\frac{1}{2}\bar{\alpha}^T\Gamma_1^{-1}\bar{\alpha}+\frac{1}{2}\bar{\beta}^T\Gamma_2^{-1}\bar{\beta}\) is chosen with the adaptation laws \(\dot{\hat{\alpha}}=\Gamma_1\sigma(\omega)e\) and \(\dot{\hat{\beta}}=\Gamma_2\sigma(\omega)v_{in}e\) where \(\Gamma_1, \Gamma_2 \in \mathbb{R}^{q \times q}\) are symmetric positive definite matrices. Again for analysis, the error terms are \(e = \omega - \omega_m\), \(\bar{\alpha} = \hat{\alpha}-\alpha\), and \(\bar{\beta}=\hat{\beta}-\beta\). Before proving \(\dot{v}(e,\bar{\alpha},\bar{\beta}) \le 0\), the time derivative \(\dot{e}\) is expanded:</p> \[\begin{aligned} \dot{e}&amp;=\dot{\omega}-\dot{\omega}_m\\ &amp;= \alpha^T\sigma + \beta^T\sigma u + a_m\omega_m-b_mr\\ &amp;= \alpha^T\sigma + \hat{\beta}^T\sigma u - \bar{\beta}^T\sigma u + a_m\omega_m - b_mr\\ &amp;= \alpha^T\sigma - \hat{\alpha}^T\sigma - a_m\omega + b_mr -\bar{\beta}^T\sigma u + a_m\omega_m - b_mr\\ &amp;= (\alpha^T\sigma-\hat{\alpha}^T\sigma)-a_m(\omega-\omega_m)-\bar{\beta}^T\sigma u\\ &amp;= -a_me-\bar{\alpha}^T\sigma(\omega)-\bar{\beta}^T\sigma(\omega)u \end{aligned}\] <p>which is done using the control law relation \(\hat{\beta}^T\sigma u = -\hat{\alpha}^T\sigma - a_m\omega + b_mr\). The time derivative of the Lyapunov function (proving negative definiteness) is thus:</p> \[\begin{aligned} \dot{v}(e,\bar{\alpha},\bar{\beta})&amp;=e\dot{e}+\bar{\alpha}^T\Gamma_1^{-1}\dot{\bar{\alpha}}+\bar{\beta}^T\Gamma_2^{-1}\dot{\bar{\beta}}\\ &amp;= e(-a_me-\bar{\alpha}^T\sigma-\bar{\beta}^T\sigma u)+\bar{\alpha}^T\Gamma_1^{-1}\dot{\bar{\alpha}}+\bar{\beta}^T\Gamma_2^{-1}\dot{\bar{\beta}}\\ &amp;= -a_me^2-e\bar{\alpha}^T\sigma - e\bar{\beta}^T\sigma u + \bar{\alpha}^T\Gamma_1^{-1}(\Gamma_1\sigma e)+\bar{\beta}^T\Gamma_2^{-1}(\Gamma_2\sigma u e)\\ &amp;= -a_me^2 \end{aligned}\] <p>using the relations \(\dot{\bar{\alpha}} = \dot{\hat{\alpha}}\) and \(\dot{\bar{\beta}} = \dot{\hat{\beta}}\).</p> <p>The tracking of this controller is presented below; the biggest differences between the linear and nonlinear approaches involve the controller’s reaction to the offset reference signals. The offset signals push the motor plant into a completely different nonlinear regime, and the linear MRAC assumption of \(\dot{\omega}= a\omega+bv_{in}\) results in poor performance. However, the nonlinear MRAC explicitly models these nonlinearities using RBFs, allowing the controller to estimate the nonlinear functions of \(\omega\) instead of the model constants.</p> <div class="row mt-3"> <div class="col-12 col-md-7 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/nonlinear-mrac-tracking-480.webp 480w,/assets/img/nonlinear-mrac-tracking-800.webp 800w,/assets/img/nonlinear-mrac-tracking-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/nonlinear-mrac-tracking.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Tracking performances for the nonlinear-RBFN MRAC for the square, sine, and sawtooth reference signals. </div> <p>The initial values for \(\alpha\) and \(\beta\) have significant effects on the results. The adaptations guarantees tracking stability, but not parameter convergence, so depending on the initial RBF weights, the controller may take a long time to become useful. If there was additional knowledge of the system dynamics, especially for the physics-based elements, the centers can be picked around regions where friction changes rapidly and \(\epsilon\) can be widened or narrowed to match expected values, which would reduce error and parameter drift. The biggest tradeoff is the size of the RBFN; smaller-dimension RBFs are under-parameterized which results in \(\sigma(\omega)\) being unable to represent the nonlinearities well. Thus, a moderate size must be tuned to allow enough flexibility to approximate the nonlinearities such that the parameter norms stay reasonable</p> <hr/> <h3 id="sliding-mode-control">Sliding Mode Control</h3> <p>As opposed to adaptive control which seeks to estimate and adjust a control law to the unknown dynamics of a system, sliding mode control (SMC) forces the dynamics to conform to a predefined stable manifold within the subspace. Given the full system dynamics of the plant,</p> \[\dot{\theta} = \omega \quad\quad\quad \dot{\omega}=f(\omega)+g(\omega)v_{in}\] <p>the sliding surface \(s = a\theta+\omega\) with \(a \ge 0\) is chosen. On the surface \(s = 0\) we have:</p> \[a\theta+\omega=0 \implies \omega = -a\theta\] <p>With \(\dot{\theta}=\omega\), along the surface is:</p> \[\dot{\theta}=-a\theta\] <p>This is a stable first-order linear ODE with the solution \(\theta(t)=\theta(t_0)e^{-a(t-t_0)}\). Since \(a \ge 0\), it is guaranteed that \(\lim_{t\rightarrow \infty} \theta(t) = 0\). Therefore, if the state can be constrained to this surface, the state will go to zero. A key component of SMC is bounding the value:</p> \[\left | \frac{a\omega-f(\omega)}{g(\omega)} \right | \le \rho(\omega)\] <p>To bound this value with the electromechanical system, it is assumed that the system has aerodynamic drag and Coulomb friction with dynamics of the form:</p> \[\dot{\omega}=bv_{in}-c_l\omega-c_a\omega^2-f_c\operatorname{sign}(\omega)\] <p>Thus, in the initial SMC notation, \(g(\omega) = b\), \(f(\omega)=-c_l\omega-c_a\omega^2-f_c\operatorname{sign}(\omega)\) and the bounded value becomes:</p> \[\left | \frac{(a+c_l)\omega+c_a\omega^2+f_c\operatorname{sign}(\omega)}{b} \right | \le \rho(\omega)\] <p>Given that \(v_{in}\) has a maximum value of 14 V and the chosen control law \(v_{in} = -\beta(\omega)\operatorname{sign}(s)\) where \(\beta(\omega) \ge \rho(\omega)+\beta_0\) and \(\beta_0 &gt; 0\), the inequality that relates the value \(a\) to the other model parameters as derived:</p> \[|v_{in}|\le 14 \implies \beta(\omega) \le 14 \rho(\omega)+\beta_0 \le 14 \implies \left | \frac{(a+c_l)\omega+c_a\omega^2+f_c\operatorname{sign}(\omega)}{b} \right | + \beta_0 \le 14\] <p>Finally, for a range of \(\omega\), \(a\) is chosen such that:</p> \[|(a+c_l)\omega+c_a\omega^2+f_c\operatorname{sign}(\omega)| \le b(14-\beta_0)\] <p>The model parameters for the following experiments are chosen as \(b = 1 rad/s^2/V\), \(c_l = 0.01 1/s\), \(c_a = 0.025 1/rad\), and \(f_c = 2.5 m/s^2\).</p> <hr/> <h4 id="smc-experiments">SMC Experiments</h4> <p>Under the previously established assumptions, it is shown that the control law \(v_{in} = -14\operatorname{sign}(s)\) will work as a sliding mode controller for the system. Over the entire range of \(\omega\), the curve \(\rho(\omega)\) stays below the constraint \(\beta = 14\) and the chosen control law is strong enough to dominate the worst-case drag and Coulomb friction and force trajectories toward the surface \(s = 0\). For \(a = 0.001\), \(\rho(\omega)\) is relatively small and there is tight chattering around zero speed with essentially no drift. In the second case of \(a = 0.01\), there is more coupling between position and speed, so the average value of \(\omega\) shifts slightly away from zero as \(\theta\) evolves; however, the system still remains close to the sliding surface with similar chattering.</p> <div class="row mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/smc-a-0.001-480.webp 480w,/assets/img/smc-a-0.001-800.webp 800w,/assets/img/smc-a-0.001-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/smc-a-0.001.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/smc-a-0.01-480.webp 480w,/assets/img/smc-a-0.01-800.webp 800w,/assets/img/smc-a-0.01-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/smc-a-0.01.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> SMC trajectories for the control law v = -14sign(s) showing fast convergence to the manifold. </div> <p>As opposed to the previous cases, when \(a = 0.1\), SMC breaks as \(\rho(\omega) &gt; \beta = 14\). The function \(\omega(t)\) does not hover around a constant value and instead slowly drifts upwards. Increasing \(a\) makes the sliding surface steeper in the state space and thus the controller has to fight harder against the plant nonlinearities.</p> <div class="row mt-3"> <div class="col-12 col-md-7 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/smc-a-0.1-480.webp 480w,/assets/img/smc-a-0.1-800.webp 800w,/assets/img/smc-a-0.1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/smc-a-0.1.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Example SMC trajectory under the previous control law in which the inequality is violated. </div> <hr/> <h4 id="chatter">Chatter</h4> <p>To make the trajectories of \(\omega\) less jarring, \(\beta(x)\) can be modified to be large enough to satisfy \(\beta(x) &gt; \rho(\omega)\) but not too large as to not cause severe chatter. The constant \(\beta = 14\) is much larger than needed for most \(\omega\) values and large \(\beta\) forces \(v_{in} = -\beta\operatorname{sign}(s)\) to switch violently. A new switching gain is designed as:</p> \[\beta(x)=\rho(\omega)+\beta_{margin}\] <p>where \(\beta_{margin}\) is a small positive constant. The new gain is also enforced by:</p> \[\beta(x) = \max(\rho(\omega)+\beta_{margin},\beta_{min})\] <p>with \(\beta_{min} = 3\). The new design shows a much smoother trajectory and a smaller oscillation amplitude that preserves the sliding behavior</p> <div class="row mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/smc-a-0.001-better-480.webp 480w,/assets/img/smc-a-0.001-better-800.webp 800w,/assets/img/smc-a-0.001-better-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/smc-a-0.001-better.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/smc-a-0.01-better-480.webp 480w,/assets/img/smc-a-0.01-better-800.webp 800w,/assets/img/smc-a-0.01-better-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/smc-a-0.01-better.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Modified SMC trajectories with a modified beta function integrated in the control law. </div> <p>Another way of confronting the chatter is to add a smoothing function in the control law, which can be done by using:</p> \[v_{in}=-\beta(x)\tanh(\alpha \omega)\] <p>for varying \(\alpha\). The tanh controllers clearly give much smaller amplitude oscillations than previous controllers. By increasing \(\alpha\), the controller gains tighter tracking that is more robust but results in more chatter whereas decreasing \(\alpha\) leads to smoother control with less chatter but softer response. As \(\alpha \rightarrow \infty\), the tanh function begins to approximate the signum function, which was the original function inside the control law, and this evolution can be observed below.</p> <div class="row mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/smc-a-0.001-tanh-480.webp 480w,/assets/img/smc-a-0.001-tanh-800.webp 800w,/assets/img/smc-a-0.001-tanh-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/smc-a-0.001-tanh.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/smc-a-0.01-tanh-480.webp 480w,/assets/img/smc-a-0.01-tanh-800.webp 800w,/assets/img/smc-a-0.01-tanh-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/smc-a-0.01-tanh.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Smoothing effects using the hyperbolic tangent function compared with previous SMC trajectories. </div>]]></content><author><name></name></author><summary type="html"><![CDATA[Control system design using Lyapunov stability and sliding manifolds]]></summary></entry><entry><title type="html">Basic and optimal control of a double pendulum</title><link href="https://domsav13.github.io/blog/2025/pendulum/" rel="alternate" type="text/html" title="Basic and optimal control of a double pendulum"/><published>2025-10-14T15:12:00+00:00</published><updated>2025-10-14T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2025/pendulum</id><content type="html" xml:base="https://domsav13.github.io/blog/2025/pendulum/"><![CDATA[<h3 id="the-double-pendulum">The Double Pendulum</h3> <p>The topic of study is the double pendulum system below, with angular states \(\theta_1\), \(\theta_2\), \(\omega_1\), and \(\omega_2\). The full system dynamics are modeled separately as Python simulator to be compared with the linearization derived below.</p> <p>img</p> <p>The dynamics of the system can be described as [ M(\theta)\,\dot{\boldsymbol{\omega}} = \boldsymbol{f}(\theta,\boldsymbol{\omega}) ]</p> <p>where [ M(\theta) = \begin{bmatrix} \frac{1}{3}m_1 l_1^2</p> <ul> <li>m_2!\left(l_1^2 + l_1 l_2 c_2 + \frac{1}{3}l_2^2\right) &amp; m_2!\left(\frac{1}{3}l_2^2 + \frac{1}{2}l_1 l_2 c_2\right) \[6pt] m_2!\left(\frac{1}{3}l_2^2 + \frac{1}{2}l_1 l_2 c_2\right) &amp; \frac{1}{3}m_2 l_2^2 \end{bmatrix} ]</li> </ul> <p>[ \boldsymbol{f}(\theta,\boldsymbol{\omega}) = \begin{bmatrix} m_2 l_1 l_2 s_2 \omega_1 \omega_2</p> <ul> <li>\frac{1}{2}m_2 l_1 l_2 s_2 \omega_2^2</li> <li>\left(\frac{1}{2}m_1 + m_2\right) g l_1 s_1</li> <li>\frac{1}{2}m_2 g l_2 s_{12}</li> <li>\tau \[6pt] \frac{1}{2}m_2 g l_2 s_{12}</li> <li>\frac{1}{2}m_2 l_1 l_2 s_2 \omega_1^2</li> <li>\tau \end{bmatrix} ]</li> </ul> <p>where \(c_i = \cos(\theta_i)\), \(s_i = \sin(\theta_i)\), and \(s_{ij} = \sin(\theta_i + \theta_j)\). An equilibrium is defined by \(\dot{x} = 0\), where both angular velocities are zero and remain zero at that state. At the origin of this system, \(c_1 = c_2 = \cos(0) = 1\) and \(s_1=s_2=s_{12}=\sin(0)=0\). Assuming there is no external input, all terms in the rightmost matrix disappear, impling all states are zero. Hence when \((\theta_1, \theta_2, \omega_1, \omega_2) = (0,0,0,0)\), and \(\tau = 0\), \(\dot{\theta}_1 = \dot{\theta}_2 = \dot{\omega}_1 = \dot{\omega}_2 = 0\) and therefore the origin of the state space is an equilibrium point.</p> <p>To model the system around the origin, small-angle approximations \(\sin(\theta_i) = \theta_i\) and \(\cos(\theta_i) = 1\) are used. The model parameters are taken as \(m_1 = 0.5\) kg, \(m_2 = 0.5\) kg, \(l_1 = 1.0\) m, \(l_2 = 1.0 m\), and \(g = 9.81\) m/s^2. Under these assumptions and parameters, the linearized system \(\dot{x} = Ax+B\tau\) is:</p> \[\dot{x} = \begin{bmatrix}\dot{\theta}_1\\\dot{\theta}_2\\\dot{\omega}_1\\\dot{\omega}_2\end{bmatrix} = \begin{bmatrix}0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\\-12.61&amp;12.61&amp;0&amp;0\\16.82&amp;-46.25&amp;0&amp;0\end{bmatrix}x + \begin{bmatrix}0\\0\\-8.57\\27.43\end{bmatrix}\tau\] <p>The eigenvalues of the state matrix \(A\) are \(\pm 7.19i\) and \(\pm 2.68i\). All eigenvalues are purely imaginary therefore the linearized system is Lyapunov stable (marginally stable) but not bounded-input bounded-output stable (asymptotically stable).</p> <h3 id="controls">Controls</h3> <p>To determine controllability, the controllability matrix \(C = \begin{bmatrix}B&amp;AB&amp;...&amp;A^{n-1}B\end{bmatrix}\) is computed:</p> \[C = \begin{bmatrix}0&amp;-8.57&amp;0&amp;454.06\\0&amp;27.43&amp;0&amp;-1412.64\\-8.57&amp;0&amp;454.06&amp;0\\27.43&amp;0&amp;-1412.64&amp;0\end{bmatrix}\] <p>The rank of \(C\) is 4, matching the dimension of state matrix \(A\), thus the system is controllable with the specified input.</p> <h4 id="linear-dynamics">Linear Dynamics</h4> <p>For this linearization, poles can be chosen using a controller of the form $u=-Kx$ to assign stable poles to the closed-loop state matrix $A-BK$. To test the performance of the controller, the following gains were computed using the place_poles function from scipy.signal to ensure stable poles:</p> \[\begin{aligned} K_1 &amp;= \begin{bmatrix}-5.11 &amp; -2.79 &amp; 0.15 &amp; 0.26\end{bmatrix} \\ \lambda(A-BK_1) &amp;= [-2\pm 3i,\,-1\pm 2i] \\ \\ K_2 &amp;= \begin{bmatrix}-5.49 &amp; -1.60 &amp; 8.27 &amp; 2.95\end{bmatrix} \\ \lambda(A-BK_2) &amp;= [-2\pm 3i,\,-3\pm 4i] \end{aligned}\] <p>Using these feedback gains, the state solutions and controll efforts are plotted below with initial conditions assigned as \(x_0 = 0.01\). As expected, the controller takes less time to reach a steady state with decreasing negative real parts in the chosen poles. However, even though the system reaches a steady state faster at these gains, there is higher variance in the state behavior, especially as illustrated by \(\omega_2\) for \(K_2\) gains.</p> <p>img here</p> <p>There are several limits for choosing pole locations for the double pendulum system. First, placing the poles too far left on the s-plane (large negative real parts) results in the feedback gain \(K\) growing significantly, meaning the controller may demand torques exceeding the actuator capabilities.</p> <h4 id="nonlinear-dynamics">Nonlinear Dynamics</h4> <p>To illustrate the differences due to the linear approximation and small-angle assumptions, the \(K_1\) and \(K_2\) control laws are applied to the nonlinear double pendulum plant simulator.</p> <p>img here</p> <p>As observed, the state diverge as time increases and the control law with faster closed-loop poles results in much higher and less bounded state changes. When both angular states are near zero, the nonlinear dynamics match the linear model closely, resulting in a region where pole placements with negative real parts stabilize. However, as angles grow, the differences between the gains become more obvious. Faster poles result in larger gains which push the system outside of the linear region, and the controller, instead of balancing the dynamics, contributes to the divergence of the states.</p> <h4 id="observation">Observation</h4> <p>For observability, we introduce \(y = Cx\) where the \(C\) matrix indicates sensors on certain states. Assuming a sensor that measures \(\theta_2\), the \(C\) matrix becomes \(\begin{bmatrix}0&amp;1&amp;0&amp;0\end{bmatrix}\). The observability matrix \(O = \begin{bmatrix}C&amp;CA&amp;...&amp;CA^{n-1}\end{bmatrix}^T\) can be computed as:</p> \[O = \begin{bmatrix}0&amp;1&amp;0&amp;0\\0&amp;0&amp;0&amp;1\\16.82&amp;-46.25&amp;0&amp;0\\0&amp;0&amp;16.82&amp;-46.25\end{bmatrix}\] <p>The observability matrix has rank 4, matching the dimension of \(A\), which means the true state of the system with this sensor is observable.</p> <h4 id="linear-dynamics-1">Linear Dynamics</h4> <p>With the state observer, the goal is to design an estimator gain \(L\) such that the estimator error \(\tilde{x} = x - \hat{x}\) follows \(\dot{\tilde{x}} = (A-LC)\tilde{x}\). Choosing eigenvalues of \(A - LC\) to ensure pole placement in the left half of the s-plane makes the observer stable. As of now, the true state is used for feedback instead of the state estimator: \(u = -Kx\). In this analysis, the state observer poles are chosen by tripling the values used in \(K_1\), ensuring faster poles than the controller. Under this setup, the state estimators quickly converge to the true states:</p> <p>img here</p> <p>While it can be inferred above, below shows how the estimation error converges before the states reach zero. This is to be later compared with the outcome of the same setup using the nonlinear double pendulum simulator.</p> <p>img here</p> <h4 id="nonlinear-dynamics-1">Nonlinear Dynamics</h4> <p>For the nonlinear case, it is expected that the observer performs well for a short region of acceptance before the error diverges. Under the same setup, the estimator gain \(L\) is passed through the double pendulum simulator.</p> <p>img here</p> <p>As expected, by choosing faster poles, the observer gain \(L\) is very large and when the plant becomes nonlinear, the measurement \(y = Cx\) no longer corresponds to the true state, causing \(\hat{x}\) to overshoot and diverge. The error \(x - \hat{x}\) follows the same divergence pattern, which illustrates the major shortcomings of the linearization used in the initial problem setup.</p> <h3 id="linear-quadratic-regulator">Linear Quadratic Regulator</h3> <p>A linear quadratic regulator (LQR) is an optimal control strategy for dynamic systems that minimizes a quadratic cost function to balance performance and control effort by calculating a gain the determines control input as a combination of the system’s current state. In this design, a \(Q\) matrix is used to weigh states and a \(R\) matrix is used to weigh control effort. With a baseline design of \(Q = R = I\), the process to formulate the LQR gain \(K\) begins with solving for \(P\) in the continuous-time algebraic Riccati equation: \(A^TP+PA-PBR^{-1}B^TP + Q = 0\). Then, the LQR gain matrix is computed as \(K = R^{-1}B^TP\).</p> <p>To evaluate LQR performance for a trajectory, the immediate loss \(l(t)\) and total loss \(J(t)\) are computed and plotted as:</p> \[l(t)=x^TQx+u^TRu \quad\quad\quad J(t) = \int_0^t l(\tau)\] <h4 id="linear-dynamics-2">Linear Dynamics</h4> <p>First, the LQR gain is used on the linearized model of the double pendulum. The states start at small initial conditions and then begin to oscillate while remaining bounded. The oscillations are damped this way because the \(Q = R = I\) setup gives roughly equal weight to the states and input. The states do not diverge and the trajectory implies stability, boundedness, and effort minimization which are all expected otucomes of the LQR solution.</p> <p>img</p> <p>To show optimality, the LQR gain is scaled to be higher for a comparison and the losses are assessed. For scale factor greater than one, the controller becomes more aggressive, applying stronger feedback than optimal. It is observed that after about 0.5 seconds, the loss representing higher gain sits slightly above the LQR loss, implying that the controller generates more control energy which has a higher cost at each instant. The conclusion is that the LQR solution achieves the same (or faster) convergence than nearby controllers with less total effort, proving optimality.</p> <p>img here</p> <p>To measure the impact of the \(Q\) and \(R\) matrices, three experiments are designed: one that heavily weights the positions, one that heavily weighs the velocities, and one that inflicts a higher cost on the control input. The angle-heavy design tries to correct angles faster, which results in slightly more aggressive changes in the state norm before settling close to the baseline whereas the velocity-heavy design instantly damps velocities hard, resulting in overshoot and slower decay. Lastly, only increasing the \(R\) matrix penalizes control effort, resulting in the smallest control signals and the slowest decay.</p> <p>img here</p> <h4 id="nonlinear-dynamics-2">Nonlinear Dynamics</h4> <p>For each case, the LQR is implemented on the simulator and the state norms for each case are measured. Most notably, the velocity-heavy \(Q\) diverges fastest and is most unstable under the nonlinear dynamics because it does not adjust angular displacement well. The baseline and angle-heavy \(Q\) designs both grow but more moderately and remain somewhat bounded for small intervals of time. Lastly, the large \(R\) design produces gentle motion which keeps the pendulum in a more linear neighborhood and is effectively more stable than the other designs.</p> <p>img here</p> <p>The nonlinear control efforts are around an order of magnitude larger because the nonlinear dynamics at moderate angles are harder to combat. For the angle-heavy \(Q\), the control effort drops rapidly once angles are reduced, as expected. The velocity-heavy \(Q\) penalizes the angular velocities very strongly and the controller overreacts to small errors, resulting in large torque oscillations under the nonlinear dynamics. As before, the large \(R\) controller stays near the equilibrium region where the linear model is more valid.</p> <p>img here</p> <h3 id="kalman-filter">Kalman Filter</h3> <p>A Kalman filter estimates the state of a dynamic system by combining predictions with noisy measurements. It works by first estimating the state and its uncertainty followed by updating the estimate using a new measurement, giving more weight to the prediction or measurement based on their certainty. For systems with Gaussian noise, the Kalman filter provides the statistically optimal estimate of the system’s state.</p> <p>For the following analyses, a sensor is assigned to measure \(\theta_2\), with \(C = \begin{bmatrix}0&amp;1&amp;0&amp;0\end{bmatrix}\).</p> <h4 id="continuous-filter">Continuous Filter</h4> <p>For the continuous-time Kalman filter, the double pendulum system is modeled as</p> \[\dot{x}=Ax+Bu+w \quad\quad\quad y=Cx+v\] <p>where \(w\) and \(v\) represent the process and measurement noises, corresponding to the noise variance matrices \(M = 0.01I\) and \(N = 0.1\), respectively. The observer estimates the state as:</p> \[\dot{\hat{x}}=A\hat{x}+Bu+L(y-C\hat{x})\] <p>where \(\hat{x}\) is the estimated state and \(L\) is the Kalman gain. By defining the estimation error as \(e = x - \hat{x}\), the error dynamics are characterized by:</p> \[\dot{e} = (A-LC)e+w-Lv\] <p>The observer dynamics are governed by \(A-LC\) and thus the observer is stable if all eigenvalues of \(A-LC\) have negative real parts. To minimize the steady-state estimation error covariance \(P = \mathbb{E}[ee^T]\), \(P\) is solved from the continuous-time algebraic Riccati equation \(AP+PA^T-PC^TN^{-1}CP+M=0\). Then, the Kalman gain is given by \(L = PC^TN^{-1}\).</p> <p>Below, the true angles \(\theta_1\) and \(\theta_2\) are presented with their estimates, showing smooth and stable convergence. For this experiment, the assumed noise covariances match model reality, and the Kalman gain \(L\) gives an optimal balance between model prediction and sensor correction. The estimates follow the true trajectories with some lag and reduced amplitude which are typical of a Kalman filter when the assumed covariances match. The eigenvalues of \(A - LC\) all have negative real parts, confirming a stable observer, which is further conveyed by the boundedness of the error \(x - \hat{x}\).</p> <p>img here</p> <p>The next figure presents the mismatched noise case where the filter assumes incorrect covariances when solving for \(L\), with \(M_{new} = 100M\) and \(N_{new} = 0.01N\). In this case, the filter believes the model is much noisier and the sensor is much more accurate than it really is. As a result, the estimates react strongly to measurement variations, producing visibly higher-frequency fluctuations. Compared to the matched noise case, the mismatched design trades off noise rejection for responsiveness.</p> <p>img here</p> <h4 id="discrete-filter">Discrete Filter</h4> <p>For the discrete model, the state space is given by:</p> \[x_{k+1}=Ax_k+Bu_k+w_k \quad\quad\quad y_k=Cx_k+v_k\] <p>with the same Gaussian noise setup as before. For the prediction step, the filter predicts the next state and covariance based on prior estimates</p> \[\hat{x}_{k|k-1}=A\hat{x}_{k-1|k-1}+Bu_{k-1} \quad\quad\quad P_{k|k-1}=AP_{k-1|k-1}A^T+M\] <p>and once a measurement \(y_k\) arrives, the prediction is corrected in the update stage and the discrete Kalman gain \(K_k\) is computed:</p> \[\begin{aligned} K_k &amp;= P_{k|k-1}C^T\left(CP_{k|k-1}C^T+N\right)^{-1} \\ \hat{x}_{k|k} &amp;= \hat{x}_{k|k-1}+K_k\left(y_k-C\hat{x}_{k|k-1}\right) \\ P_{k|k} &amp;= \left(I-K_kC\right)P_{k|k-1} \end{aligned}\] <p>where $P_{k|k}$ is the updated error covariance and $P_{k|k-1}$ is the predicted error covariance. At steady state, $K_k$ and $P_k$ converge to constant values where $P$ solves the discrete-time algebraic Riccati equation \(P = APA^T+M-APC^T\left(CPC^T+N\right)^{-1}CPA^T\) Then, the Kalman gain is computed as \(K = PC^T\left(CPC^T+N\right)^{-1}\)</p> <p>img here</p> <p>As seen above, teh estimates closely track the true angles but appear somewhat noisy, due to the measurement noise \(v_k\) being incorporated during each update. Both estimates remain bounded and follow the correct trends, showing that the filter is stable and performing proper sensor fusion. In the subplot, the trace of \(P_k\) measures the total uncertainty in the state estimate and settles to a steady-state value, implying the convergence of the discrete-time Riccati equation.</p> <h4 id="nonlinear-filter">Nonlinear Filter</h4> <p>To generalize the discrete Kalman filter to the nonlinear dynamics, an extended Kalman filter (EKF) is designed as follows:</p> \[x_{k+1}=f(x_k,u_k)+w_k \quad\quad\quad y_k=h(x_k)+v_k\] <p>where $f$ and $h$ are nonlinear functions. The nonlinear dynamics are approximated by their first-order Taylor expansion, producing local Jacobians that replace the fixed $A$ and $C$ matrices of the linear filter:</p> \[F_k = \left.\frac{\partial f}{\partial x}\right|_{\hat{x}_k,u_k} \qquad\qquad H_k = \left.\frac{\partial h}{\partial x}\right|_{\hat{x}_{k+1|k}}\] <p>As illustrated below, the EKF simulation demonstrates stable and accurate estimation fot eh nonlinear dynamics when the system remains close to the linearization point. The estimator successfully reconstructs both measured and unmeasured angles with bounded estimation error and a decreasing covariance trace, however performance degrades as the system departs from the validity of the local Jacobians.</p> <p>img here</p> <h4 id="estimated-state-feedback">Estimated State Feedback</h4> <p>This section demonstrates how the LQR feedback loop and the Kalman filter estimation loop interact when the filters are supplying feedback. The figure below describes how the estimated state feedback behaves when the relative speeds of the controller (LQR gain \(K\)) and the state estimator (Kalman filter gain \(L\)) are scaled:</p> \[K_c = \alpha K \quad\quad\quad L_c = \beta L\] <p>where \(\alpha\) controls how aggressively the controller responds and \(\beta\) controls how aggressively the Kalman filter trusts measurements.</p> <p>img here</p> <p>In the first scenario, the controller reacts slowly and the filter reacts aggressively, resulting in an estimator that tracks well but with small control in the linear model. In the nonlinear case, however, the filter overreacts to noisy measurement and the controller thus acts on inaccurate estimates. For the opposite case, with an aggressive controller and slow filter, the linear system rapidly stabilizes. In the nonlinear case, the controller reacts much faster than the EKF can estimate, so inputs are based on distorted estimates, leading to instability and very high cost. When the subsystems are scaled in tandem, the linear model produces a smooth, well-damped response with moderate inputs. Most notably, the EKF for the nonlinear model estimates states accurately enough to maintain reasonable feedback. The controller and observer operate on compatible time scales, resulting in the best performing configuration for the nonlinear system.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Control system design using pole placement, linear quadratic regulator, and Kalman filter]]></summary></entry><entry><title type="html">System Identification of a DC Motor</title><link href="https://domsav13.github.io/blog/2025/sys-id/" rel="alternate" type="text/html" title="System Identification of a DC Motor"/><published>2025-09-10T15:12:00+00:00</published><updated>2025-09-10T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2025/sys-id</id><content type="html" xml:base="https://domsav13.github.io/blog/2025/sys-id/"><![CDATA[<p>This project investigates system identification of a DC motor simulator using both analytical and data-driven methods. A white-box state-space model was first derived to establish the expected dynamics, step and frequency responses were measured, and then black-box methods were trained on the data to model and predict the behavior of the full electromechanical system.</p> <hr/> <h3 id="white-box-approach">White Box Approach</h3> <p>An electric DC motor is connected to a wheel with linear damping \(c\) and inertia \(J\). The motor generates a torque \(\tau\) with some angular velocity \(\omega\) which is related to the back emf \(v_{emf}\) by the motor constant \(K_v\). The motor converts electrical power to mechanical power with efficiency \(\eta\), with the equations:</p> \[\begin{aligned} \omega = K_v v_{emf} \quad\quad\quad \eta = \frac{P_{out}}{P_{in}} \end{aligned}\] <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/motor-480.webp 480w,/assets/img/motor-800.webp 800w,/assets/img/motor-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/motor.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> A DC motor connected to a wheel, the overarching schematic for this system identification analysis. </div> <p>Using the efficiency equation with mechanical and electrical power, the relation between current \(i_m\) and torque \(\tau\) is given by:</p> \[\begin{aligned} P_{out}&amp;=\eta P_{in}\\ \tau \omega &amp;= \eta i_m v_{emf}\\ \tau K_v v_{emf} &amp;= \eta i_m v_{emf}\\ \frac{K_v}{\eta} \tau &amp;= i_m \end{aligned}\] <p>Applying Newton’s law of rotation to the system, the mechanical equation of motion is \(J \dot{\omega} = \tau - c \omega\).</p> <p>Applying Kirchoff’s current and voltage laws with the current \(i_m\), the electrical equation of motion is \(v_{in} = v_{emf} + R_m i_m\).</p> <p>Combining both equations of motion with the given relations:</p> \[\begin{aligned} J\dot{\omega}&amp;=\frac{\eta}{K_v}i_m-c\omega\\ J\dot{\omega}&amp;=\frac{\eta}{R_mK_v}\left(v_{in}-v_{emf}\right)-c\omega\\ J\dot{\omega}&amp;=\frac{\eta}{R_mK_v}\left(v_{in}-\frac{\omega}{K_v}\right)-c\omega\\ J\dot{\omega}&amp;=\frac{\eta}{R_mK_v}v_{in}-\left(c+\frac{\eta}{R_mK_v^2}\right)\omega \end{aligned}\] <p>In state-space form, the system is represented by:</p> \[\dot{x}=\begin{bmatrix}\dot{\omega}\\\dot{\theta}\end{bmatrix}=\begin{bmatrix}\frac{-\eta}{JR_mK_v^2}-\frac{c}{J}&amp;0\\1&amp;0\end{bmatrix}\begin{bmatrix}\omega\\\theta\end{bmatrix}+\begin{bmatrix}\frac{\eta}{JR_mK_v}\\0\end{bmatrix}v_{in}=Ax+Bu\] <p>Using these matrices, the analytical solution \(x(t)\) given an input \(u(t)\) is formulated as:</p> \[x(t)=e^{At}x_0+\int_0^t e^{A(t-\tau)}Bu(\tau)d\tau\] <p>For the next analyses, parameters are chosen. The resistance of the motor coil is \(R_m = 2 \Omega\), the moment of inertia of the wheel is \(J = 0.004 kgm^2\), the linear damping coefficient of the wheel is \(c = 0.015 \frac{Ns}{mrad}\), the motor constant is \(K_v = 100 \frac{rad}{sV}\), and the efficiency is \(\eta = 0.9\).</p> <p>With the chosen parameters, the analytical solution \(x(t)\) is illustrated for a unit step input (\(u(\tau)=v_{in}(t)=1\)) and five randomized initial conditions near zero, showing how each state \(\omega(t)\) and \(\theta(t)\) respond to such an input.</p> <div class="row mt-3"> <div class="col-12 col-md-7 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/step-comparisons-480.webp 480w,/assets/img/step-comparisons-800.webp 800w,/assets/img/step-comparisons-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/step-comparisons.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Unit step response of the motor simulator states with randomized initial conditions. </div> <p>Finally, the poles of the system are analyzed, which dictate the stability and how a response may oscillate and settle over time. THe poles are the eigenvalues of the state matrix A:</p> \[A=\begin{bmatrix}\frac{-\eta}{JR_mK_v^2}-\frac{c}{J}&amp;0\\1&amp;0\end{bmatrix}=\begin{bmatrix}-3.7388&amp;0\\1&amp;0\end{bmatrix}\] <p>The characteristic equation is \(\Delta(s) = s(s+3.7388)\) thus the system has 2 poles, one at 0 and one at -3.7388.</p> <hr/> <h3 id="step-response">Step Response</h3> <p>In this section, motor velocity \(\omega(t)\) step responses from the motor plant simulator will be normalized and singular value decomposition (SVD) will be used to estimate the nonzero pole \(a\). The first order dynamics of the system can be modeled by a pole at \(a\) and a DC gain \(K_{DC}\), which is estimated from the final value of a response once the system has settled to a stable state. With zero initial conditions, these dynamics can be expressed as</p> \[\dot{x}=ax+\frac{K_{DC}}{a}v_{in}\] <p>the \(k\) step response to which is \(x(t) = kK_{DC}(1-e^{at})\). With simulated data allowing nonzero initial conditions, however, the first-order step response becomes \(x(t) = kK_{DC}+(x_0-kK_{DC})e^{at}\). The normalization is thus:</p> \[\hat{x}(t)=1-\frac{x(t)-x_0}{kK_{DC}-x_0}=e^{at}\] <p>This normalization allows for the estimation of \(a\) through the SVD least squares fit of \(\ln \hat{x}(t) = at\).</p> <p>For 50 velocity simulations, the normalized responses are shown. Initial conditions for \(\omega(0)\) were randomized in [-6,6] rad/s and \(\theta(0)\) in [-0.5,0.5] rad. The step magnitude \(k\) was randomly chosen in [1,12] V. The DC gain \(K_{DC}\) was estimated using the final 10 percent of each response.</p> <div class="row mt-3"> <div class="col-12 col-md-7 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/normalized-responses-480.webp 480w,/assets/img/normalized-responses-800.webp 800w,/assets/img/normalized-responses-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/normalized-responses.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Normalized step responses from 50 simulations of the motor velocity with randomized initial conditions and step inputs. </div> <p>These simulations returned an average pole of \(m_a = -3.50\) with standard deviation \(\sigma_a=1.00\) using a fine mesh of \(\Delta t = 0.001\) over a 3 second total time. With the noise and nonlinearities included in the simulator, the pole falls within the expected range of values predicted by the white box approach. Using a more coarse time interval leads to high-variance least squares results, most likely due to the noise present.</p> <hr/> <h3 id="frequency-response">Frequency Response</h3> <p>In this section, a sinusoidal input is used to determine the frequency response of the system. An input \(u(t) = A\sin(\omega t)\) results in a response of the form \(x(t) = GA\sin(\omega t + \phi)\) with a gain \(G\) and phase shift \(\phi\) which are found using a gradient descent method. Gradient descent methods update the desired parameters by means of predefined loss functions, which are used here to fit sine waves to the motor plant output at different frequencies, and to fit the first order Bode plot. To mirror data sampled from the step response simulations, the sinusoidal input is forced to be positive in the range [0,12] V using \(u(t) = V_{bias} + A\sin(\omega t)\) where \(V_{bias} = 6\) and \(A \in (0,6]\).</p> <p>To fit the sinusoidal response, the motor plant output is assumed to take the form \(y(t) \approx a\sin(\omega t) + b\cos(\omega t)\) and the model is initialized as \(\hat{y}(t) = a\sin(\omega t) + b\cos(\omega t)\). The residual error is \(e(t) = \hat{y}(t)-y(t)\). The mean squared error loss function is then defined as:</p> \[J(a,b) = \frac{1}{N} \sum_{i=1}^N [e(t_i)^2]^2 = \frac{1}{N} \sum_{i=1}^N [a\sin(\omega t_i) + b\cos(\omega t_i) - y(t_i)]^2\] <p>with updates \(a \leftarrow a - lr \frac{\partial{J}}{\partial{a}}\) and \(b \leftarrow b -lr\frac{\partial{J}}{\partial{b}}\) where \(lr\) is the learning rate.</p> <p>These updates allow for the amplitude, gain, and phase to be computed as \(A = \sqrt{a^2+b^2}\), \(G = 20\log_{10}(A)\), and \(\phi = \tan^{-1}\left(\frac{b}{a}\right)\) respectively. A similar approach is used to fit the Bode plots from the simulated data. The transfer function for a first order Bode plot assumes the model \(G(s) = \frac{K}{1+s\tau}\). Additionally, the following equations are used to simplify the gain magnitude \(M(\omega)\) and phase \(\phi(\omega)\) in terms of the relevant parameters \(K\) and \(\tau\):</p> \[M(\omega)=20\log_{10}|G(i\omega)|=20\log_{10}K-10\log_{10}(1+\omega^2\tau^2) \quad\quad\quad \phi(\omega)=\angle G(i\omega)=-\tan^{-1} (\omega \tau) \frac{180}{\pi}\] <p>The desired parameters \(\theta\), in the logarithmic space, are thus the DC gain and the time constant: \(\theta = \begin{bmatrix}\log K&amp;\log\tau\end{bmatrix}^T\). The magnitude and phase errors are defined as \(e_m(\omega)=M_{model}(\omega)-M_{data}(\omega)\) and \(e_p(\omega) = \phi_{model}(\omega)-\phi_{data}(\omega)\) respectively. The loss function is defined as:</p> \[J(\theta)=\sum_{i=1}^N [e_m(\omega_i)^2+e_p(\omega_i)^2]\] <p>with the vector update \(\theta \leftarrow \theta - lr \nabla_{\theta}J\). Learning rates are adjusted each sweep. The gradient descent methods estimated the DC gain \(K = 1.5\), time constant \(\tau = 0.248\) s, and thus a pole located at frequency \(p = -4.04\) rad/s.</p> <div class="row mt-3"> <div class="col-12 col-md-7 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bode-plot-480.webp 480w,/assets/img/bode-plot-800.webp 800w,/assets/img/bode-plot-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/bode-plot.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The first order Bode plot for the frequency response of the motor plant's velocity. A stable pole is estimated as p = -4.04 rad/s. </div> <hr/> <h3 id="black-box-approaches">Black Box Approaches</h3> <p>The following sections involve using black-box techniques to generate predictive models of the motor plant simulator.</p> <h4 id="radial-basis-function-network">Radial Basis Function Network</h4> <p>The purpose of the radial basis function network (RBFN) is to approximate the discretized function that represents the electromechanical system:</p> \[x_{k+1}=f(x_k,u_k)\] <p>To train the RBFN, data from the step and frequency response simulations are loaded into $(x_i, y_i)$ pairs where $x_i = \begin{bmatrix} x_k &amp; u_k \end{bmatrix}^T$ and $y_i = x_{k+1}$ for each trajectory. The goal is to build the radial basis function matrix for a batch.</p> \[\Phi(X)_{n,i}=\phi(x_n)=\exp\!\left(-\epsilon_i \lVert z_n-c_i\rVert^2\right)\] <p>where centers $c_i$ are chosen by k-means (for several candidate number of centers $k$). Each data point is assigned to the nearest center, creating clusters where each center is recomputed as the mean of the points in its cluster. This is done iteratively until the shift of centers is below a certain tolerance. $\epsilon_i$ is found by taking the largest eigenvalue of the covariance matrix of the cluster $C_i$. Once the radial basis function matrix is built, SVD is used to find the weights $W$ that minimize $\lVert \Phi W - Y_{tr} \rVert$ where $Y_{tr}$ are the targets (next states). The process is repeated for each $k$ until the one with the lowest root mean squared error is selected for the final fit. The model’s capabilities can be visually inspected below, which shows the scope of the training data that was used.</p> <div class="row mt-3"> <div class="col-12 col-md-7 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/training-coverage-480.webp 480w,/assets/img/training-coverage-800.webp 800w,/assets/img/training-coverage-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/training-coverage.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> A scatter plot of training data (inputs and states) used on the RBFN (and later, MLP) from step and frequency response simulations. This figure will later be used to test the performance of the black-box techniques against the motor plant simulator. </div> <hr/> <h4 id="multi-layered-perceptron">Multi-Layered Perceptron</h4> <p>As a feedforward neural network, the multi-layered perceptron (MLP) approach consists of a similar architecture to that of a RBFN, except it typically has much more hidden layers where weighted inputs are passed through nonlinear activation functions. The goal remains the same, to learn a discretized state update model</p> \[x_{k+1}=f(x_k,u_k)\] <p>where \(f\) is a nonlinear mapping approximated by an MLP which is initilized here using the Tensorflow Python library. Training is done in mini-batches with the Adam optimizer and mean squared error as the loss function. Similar to RBFN training, the architecture with the lowest root means squared error is selected and saved as the final fit.</p> <p>As noted in the training coverage, data regarding step responses form horizontal bands across randomly generated initial conditions. However, most of the training data is dominated by frequency response data which covers the full range of input but only a limited amount of initial conditions. The density of the scatter plot implies strong black-box performance for positive initial conditions. By experimenting with different inputs and initial conditions, the strengths and shortcomings of the training data and RBFN/MLP methods are revealed.</p> <div class="row mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/step-good-480.webp 480w,/assets/img/step-good-800.webp 800w,/assets/img/step-good-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/step-good.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/sine-good-480.webp 480w,/assets/img/sine-good-800.webp 800w,/assets/img/sine-good-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/sine-good.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/step-bad-480.webp 480w,/assets/img/step-bad-800.webp 800w,/assets/img/step-bad-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/step-bad.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/sine-bad-480.webp 480w,/assets/img/sine-bad-800.webp 800w,/assets/img/sine-bad-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/sine-bad.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Top: step (left) and frequency (right) responses with zero initial conditions - both the RBFN and MLP gradually interpolate with less bias as the states are updated. Bottom: step (left) and frequency (right) responses with negative conditions, where the black box methods underperform due to the limitations of the training coverage. </div> <p>To improve these models, it is obvious that a wider range of initial conditions must be simulated and sampled. However, under certain conditions, the black-box methods are capable of low-bias approximations of both step and frequency responses.</p> <hr/> <h4 id="black-box-conclusions">Black Box Conclusions</h4> <p>Nonlinear systems often respond differently to small versus large inputs. Larger inputs lead to faster rise times and higher steady-state velocities, as expected from motor physics. Both the MLP and RBFN capture the general trend of higher step magnitudes, but at a certain point extrapolation becomes necessary due to the limitations of the training set.</p> <div class="row mt-3"> <div class="col-12 col-md-9 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/step-comparison-480.webp 480w,/assets/img/step-comparison-800.webp 800w,/assets/img/step-comparison-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/step-comparison.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Comparisons among varying step magnitudes. While the MLP and RBFN trend well, they struggle to interpolate at the low and high extremes of the training set. </div> <p>Regarding these two approaches, the RBFN is generally good for interpolation and weaker for extrapolation due to it being a local fit sensitive to training data density. The MLP, however, can generalize better but may smooth way details (such as the noise and nonlinearities included in the simulator). In terms of implementation, the RBFN training has proven to be way easier and practical as k-means and SVD are deterministic and require little to no tuning. On the other hand, the MLP requires the tuning of several hyperparameters (epochs, hidden layers, iterations, etc.) and may perform better as a global function approximator through iterative design. The RBFN performs well for scenarios that fall inside the training coverage whereas the MLP is expected to be more generalizable for unseen states or inputs.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[White- and black-box approaches to motor control]]></summary></entry><entry><title type="html">MAE Senior Capstone</title><link href="https://domsav13.github.io/blog/2025/capstone/" rel="alternate" type="text/html" title="MAE Senior Capstone"/><published>2025-05-10T15:12:00+00:00</published><updated>2025-05-10T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2025/capstone</id><content type="html" xml:base="https://domsav13.github.io/blog/2025/capstone/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Design and build of a maritime spotlight]]></summary></entry><entry><title type="html">IoT Christmas Tree</title><link href="https://domsav13.github.io/blog/2025/xmas-tree/" rel="alternate" type="text/html" title="IoT Christmas Tree"/><published>2025-05-10T15:12:00+00:00</published><updated>2025-05-10T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2025/xmas-tree</id><content type="html" xml:base="https://domsav13.github.io/blog/2025/xmas-tree/"><![CDATA[<p>This project presents the development of an IoT-enabled Christmas tree featuring dynamic lighting and motion responsive to sensor data and user control. A Raspberry Pi manages a WS2811 RGB LED strip, BH1750 ambient light sensor, motion sensors, and servo-driven animatronic eyes with custom 3D-printed housing. Python libraries including rpi_ws281x and Flask were used for real-time LED control and web-based customization. A six-layer IoT model guided the system architecture, combining perception, data processing, actuation, networking, and user interfacing. 3D spatial mapping of the LEDs enabled complex, geometry-based animations, while real-time ambient brightness was visualized through a web dashboard.</p> <hr/> <h3 id="methods">Methods</h3> <p>Regarding setup and LED handling, a 2-foot Christmas tree was purchased along with a strip of 50 WS2811 programmable LEDs. Additionally, an independent 5 V power supply was purchased with a DC adapter that wires directly to the LED strip via WAGO connectors. The LEDs were positioned uniformly throughout the tree for the best visual experience; due to the circuitry of the LED strip, the LEDs light up in the order they are wired when they are sequentially programmed. To achieve a broader spectrum of animations (especially those based on geometry), 3D coordinates were collected for each LED. By using a 360-degree protractor and a tape measure, polar cooridnates were collected and then converted to Cartesian coordinates for use in generating complex light patterns.</p> <p>The I2C BH1750 light sensor was chosen to detect changes in ambient brightness in tandem with the lighting setup. Regardless of LED effects, this sensor dims or amplifies brightness based on ambient light. The ambient light (and subsequent LED brightness) is published on the user interface so that peak usage times can be estimated for a continuously lit tree and energy consumption can be decreased where appropriate.</p> <div class="row mt-3"> <div class="col-12"> <div class="row justify-content-center"> <div class="col-12 col-md-5"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/xmas-tree-480.webp 480w,/assets/img/xmas-tree-800.webp 800w,/assets/img/xmas-tree-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/xmas-tree.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-12 col-md-5"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/bh1750-480.webp 480w,/assets/img/bh1750-800.webp 800w,/assets/img/bh1750-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/bh1750.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> </div> </div> <div class="caption"> Once the tree was set up, polar coordinates were utilized to generate 50 3D coordinates (X,Y,Z) of each LED for geometry-based animations. The microcomputer also used ambient light readings delivered by the BH1750 sensor to control brightness of the LEDs. </div> <hr/> <h3 id="results">Results</h3> <p>For animating the lights, several mathematical- and time-based effects were brainstormed including fireworks, twisters, heartbeats, contagious (proximity-based) effects, and random planes or rotations. Music synchronization was also explored, but remains an item under further work as automating, synchronizing, and mapping music to LED effects requires advanced signal processing methods. The code can be found at <a href="https://github.com/domsav13/iotxmastree">this GitHub repo</a>.</p> <div class="row mt-3 g-3 align-items-start"> <div class="col-12 col-md-4"> <video autoplay="" loop="" muted="" playsinline="" preload="metadata" class="img-fluid rounded z-depth-1 w-100"> <source src="/assets/img/contagious.mp4" type="video/mp4"/> </video> </div> <div class="col-12 col-md-4"> <video autoplay="" loop="" muted="" playsinline="" preload="metadata" class="img-fluid rounded z-depth-1 w-100"> <source src="/assets/img/rainbow.mp4" type="video/mp4"/> </video> </div> <div class="col-12 col-md-4"> <video controls="" playsinline="" preload="metadata" class="img-fluid rounded z-depth-1 w-100"> <source src="/assets/img/mariah-carey.mp4" type="video/mp4"/> </video> </div> </div> <div class="caption"> Simple light animations (proximity-based contagious and rainbow spiral effects). Mariah Carey's "All I Want for Christmas Is You" was also synchronized to the lights, although this was done manually instead of automated. </div> <hr/> <p>In Fall 2025, the project was expanded to a 500 LED, 7-foot Chrismas tree for the MAE department at GW. Instead of manually recording coordinates for each LED, the tree was modeled as a cone with an ascending helix representative of the LEDs spiraling throughout the tree. Using mathematical models of cones and spirals and taking basic measurements such as the upper and lower tree radii and number of turns, the 3D coordinates were parameterized for each LED index.</p> <div class="row mt-3"> <div class="col-12 col-md-6 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/500-leds-480.webp 480w,/assets/img/500-leds-800.webp 800w,/assets/img/500-leds-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/500-leds.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Wiring setup for the 500 LEDs (10 strips of 50 LEDs). The wiring required a rethinking of power distribution, as powering the LEDs in series results in diminished brightness towards the end of the strip. A solution was to inject power at both the beginning and end of the total length, which resulted in a better balance of LED brightness. </div> <p>In regards to the animations, the jump from 50 to 500 LEDs significantly increases resolution, which supports more complex effects. The full work can be found at <a href="https://github.com/domsav13/maexmastree">this GitHub repo</a>.</p> <div class="row mt-3 g-3 align-items-start"> <div class="col-12 col-md-4"> <video autoplay="" loop="" muted="" playsinline="" preload="metadata" class="img-fluid rounded z-depth-1 w-100"> <source src="/assets/img/500-contagious.mp4" type="video/mp4"/> </video> </div> <div class="col-12 col-md-4"> <video autoplay="" loop="" muted="" playsinline="" preload="metadata" class="img-fluid rounded z-depth-1 w-100"> <source src="/assets/img/up-down.mp4" type="video/mp4"/> </video> </div> <div class="col-12 col-md-4"> <video autoplay="" loop="" muted="" playsinline="" preload="metadata" class="img-fluid rounded z-depth-1 w-100"> <source src="/assets/img/snakes.mp4" type="video/mp4"/> </video> </div> <div class="caption"> Similar LED effects on the 500 LED, 7-foot Christmas tree (contagious, vertical, and snake effects). The tree is modeled as a cone with an ascending spiral representing the mapping of each LED. </div> </div>]]></content><author><name></name></author><summary type="html"><![CDATA[Coordinate- and sensor-based Christmas tree lighting]]></summary></entry><entry><title type="html">Object Tracking and Identification</title><link href="https://domsav13.github.io/blog/2025/opencv/" rel="alternate" type="text/html" title="Object Tracking and Identification"/><published>2025-03-10T15:12:00+00:00</published><updated>2025-03-10T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2025/opencv</id><content type="html" xml:base="https://domsav13.github.io/blog/2025/opencv/"><![CDATA[<p>This project explores computer vision-based object detection and facial recognition using a Raspberry Pi 4B and PiCamera V2.1 to create a compact, real-time security/detection system. The detection model captures video frames, processes them in real time, and sends notifications when a target is detected. OpenCV, a widely used computer vision library, and the COCO dataset were used to develop and train the model. The object detection performed reliably with adjustable confidence thresholds, but facial recognition struggled with prolonged use due to hardware limitations.</p> <hr/> <h3 id="background">Background</h3> <p>Using a three-layer IoT model incorporating the perception, network, and application layers, the final product seeks to generate email notifications based on visual detection methods. The work is inspired by security and privacy computer vision-based systems (Ring, Apple Face ID, etc.).</p> <p>OpenCV is a free computer vision and machine learning library built to advance machine perception in commercial products, featuring thousands of optimized algorithms that can be used to detect and recognize faces, identify objects, classify gestures, and more. The fundamentals of object detection in OpenCV involve two main tasks: classification and localization. Most methods work to determine the exact location of an object within an image or video feed by using bounding boxes or segmentation. The promises of OpenCV rely fully on the models that are provided, which is why the Common Objects in Context (COCO) dataset is essential for the success of the detection performance.</p> <p>COCO is a large-scale object detection dataset that features recognition of over 200,000 labeled images among 1.5 million object instances. The datasets are open source and available for download, and are designed to train and evaluate detection models with rich contextual data and precise localization via “segmentation masks,” a specific portion of an image that is isolated from the rest. This project will use OpenCV algorithms to train these labeled images so that a Raspberry Pi and PiCamera can detect objects and alert the user in real time.</p> <hr/> <h3 id="methods-and-implementation">Methods and implementation</h3> <p>The requirements for this project include a Raspberry Pi 4 (flashed with the Buster version of the Debian OS) and PiCamera V2.1. The camera interfaces with the microcomputer with a ribbon connector.</p> <div class="row mt-3"> <div class="col-12 col-md-5 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/eyepi-workflow-480.webp 480w,/assets/img/eyepi-workflow-800.webp 800w,/assets/img/eyepi-workflow-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/eyepi-workflow.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Software workflow for the email notification and object detection system. </div> <p>The primary goal of the code is to detect a specific object, capture an image when the object is detected, and send an email with the image attached. The pre-trained COCO dataset incorporates the labeling of 91 common everyday objects. The object detection model is configured using these COCO files to define class labels and specify weights, which is later loaded by the OpenCV deep neural network module. A video capture continuously reads frames and passes them through a function that checks whether the detected object matches the target object specified by the user. If so, it draws a bounding box and a label around the object on the image, saves it, and sends it via email. This function is central to the object detection process, as it uses a confidence and non-maximum suppression (NMS) threshold. The confidence threshold filters out low-confidence detections and the NMS thresholds reduces overlapping boxes to avoid duplicate detections. The email is sent using SMTP, EmailMessage, and a Gmail account with app passwords enabled to include a subject and body message indicating that the object was detected, attaching the saved image as well.</p> <p>All code is presented at <a href="https://github.com/domsav13/eyepi">this GitHub repo</a>.</p> <hr/> <h3 id="results">Results</h3> <p>Overall, the methods satisfied basic requirements but were limited due to hardware constraints. The limited computing power of the Raspberry Pi and low frame rates in the video feed limited the performance of the software, however the object detection model met expectations.</p> <div class="row mt-3"> <div class="col-12"> <div class="row justify-content-center"> <div class="col-12 col-md-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/detection-left-480.webp 480w,/assets/img/detection-left-800.webp 800w,/assets/img/detection-left-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/detection-left.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-12 col-md-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/detection-right-480.webp 480w,/assets/img/detection-right-800.webp 800w,/assets/img/detection-right-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/detection-right.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> </div> </div> <div class="caption"> Exclusive search within the video feed, filtering out specified objects. Bounding boxes and confidence levels are shown around each object. Left: objects=[""]; Right: objects=["CUP"]. </div> <p>There are a few hyperparameters that the user can modify. First, using an exclusive search feature of OpenCV, the user may specify which object or group of objects the detection model should look for. In other words, the user can filter out undesired objects from the detection model if only searching for instances of objects of interest. Additionally, the user may choose the confidence threshold for the detection. While objects such as cups, chairs, or people are easily detectable, there are fewer common objects that require lower confidence thresholds. A high confidence level is typically above 0.7 whereas a poor confidence is below 0.4.</p> <div class="row mt-3"> <div class="col-12"> <div class="row justify-content-center"> <div class="col-12 col-md-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/broccoli-detected-480.webp 480w,/assets/img/broccoli-detected-800.webp 800w,/assets/img/broccoli-detected-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/broccoli-detected.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-12 col-md-6"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/chair-detected-480.webp 480w,/assets/img/chair-detected-800.webp 800w,/assets/img/chair-detected-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/chair-detected.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> </div> </div> <div class="caption"> The COCO dataset used here contains 91 everyday objects, but not all are detected with high confidence by the OpenCV model. The difficulty is reflected in the confidence metric that is displayed with each bounding box. </div> <p>Lastly, the implementation of a personal security system that detects people and sends email alerts to the home user (inspired by Ring) works exceptionally well due to the high confidence of “person” in the detection model and simple, rapid communication via WiFi. Not only does the email notification include a snapshot of the detected object, it also provides a timestamp and a description of which object was detected.</p> <div class="row mt-3"> <div class="col-12 col-md-5 mx-auto mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/eyepi-email-480.webp 480w,/assets/img/eyepi-email-800.webp 800w,/assets/img/eyepi-email-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/eyepi-email.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Sample email notification with detection timestamp and "person" as the target object, sent by a third-party email account. </div>]]></content><author><name></name></author><summary type="html"><![CDATA[Pocket-sized computer vision (OpenCV)]]></summary></entry><entry><title type="html">Mini Foosball Table</title><link href="https://domsav13.github.io/blog/2024/foosball/" rel="alternate" type="text/html" title="Mini Foosball Table"/><published>2024-11-25T15:12:00+00:00</published><updated>2024-11-25T15:12:00+00:00</updated><id>https://domsav13.github.io/blog/2024/foosball</id><content type="html" xml:base="https://domsav13.github.io/blog/2024/foosball/"><![CDATA[<p>The goals of this manufacturing project were to define product specifications using CAD software, outline component requirements by developing manufacturing process plans, gain experience with simple machine shop machines (lathe, mill, drill press, etc.), manage internal and external resources, and build and test the final design.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/foosball-1-480.webp 480w,/assets/img/foosball-1-800.webp 800w,/assets/img/foosball-1-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/foosball-1.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/foosball-2-480.webp 480w,/assets/img/foosball-2-800.webp 800w,/assets/img/foosball-2-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/foosball-2.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Final product of the mini foosball table. </div> <p>The project also highlights the important differences between design for manufacturability (DFM) and design for assembly (DFA). DFM focuses on making individual parts easy and cost-effective to manufacture while DFA focuses on minimizing the time, cost, and errors involved in assembling those parts into a finished product. There are several tradeoffs that were observed between DFM and DFA, trying to bring a CAD model to life, and through understanding the practical capabilities of the available machines.</p> <hr/> <h3 id="design">Design</h3> <p>Each component was designed and modeled in SOLIDWORKS to visualize a baseline assembly. This version featured 10 player models and had dimensions 12.5 x 19.75 inches.</p> <div class="row mt-3"> <div class="col-12"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/foosball-assembly-480.webp 480w,/assets/img/foosball-assembly-800.webp 800w,/assets/img/foosball-assembly-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/foosball-assembly.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The initial CAD assembly for the mini foosball table, showing the original key components: base, goal walls, side walls, player, and rod. </div> <p>This assembly was helpful in streamlining the manufacturing process plans for the key components, but it is not representative of the final product for several reasons. During the manufacturing phase, back walls were designed and manufactured to create a space to collect the ball once a goal has been scored; bushings were selected to allow near-frictionless movement of the rods through the through holes in the side walls; player heads were 3D printed in two different colors to distinguish between teams; handles were manufactured and attached to the rods for comfortable control of players; and bumpers were added to rods with 2 players to prevent unwanted contact with the side walls.</p> <hr/> <h3 id="manufacturing-and-assembly">Manufacturing and assembly</h3> <p>A wide variety of machines were used in the manufacturing processes, including the lathe, mill, band and drop saws, and drill press. The saws were primarily used to make preliminary cuts in the raw material for each component. The drill press was used to make through holes in the side walls and the player bases. The lathe was used to turn down the players (machined using stock Aluminum) into equal sizes and was then programmed to do a revolve cut to achieve a geometry similar to a standard foosball player model. A similar approach was used to turn down the ends of the handles to make them hemispherical in shape. The lathe was further used to drill center holes in the tops of the players (for assembly with the 3D printed heads) and the handles (for assembly with the rods).</p> <swiper-container class="media-swiper" keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/player-sketch-480.webp 480w,/assets/img/player-sketch-800.webp 800w,/assets/img/player-sketch-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/player-sketch.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/player-lathe-cutting-path-480.webp 480w,/assets/img/player-lathe-cutting-path-800.webp 800w,/assets/img/player-lathe-cutting-path-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/player-lathe-cutting-path.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <video src="/assets/img/lathe_player.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" controls=""/> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/lathe-drilling-480.webp 480w,/assets/img/lathe-drilling-800.webp 800w,/assets/img/lathe-drilling-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/lathe-drilling.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> <p>The mill was then used to flatten a bottom section on the player models to create an optimal contact surface with the game ball. It was also used to create the goal cavity in the goal walls, as well as ensure that all walls are of equal height.</p> <swiper-container class="media-swiper" keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <video src="/assets/img/mill_player.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" controls=""/> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/foosball-walls-480.webp 480w,/assets/img/foosball-walls-800.webp 800w,/assets/img/foosball-walls-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/foosball-walls.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <video src="/assets/img/mill_goal.mp4" class="img-fluid rounded z-depth-1" width="auto" height="auto" controls=""/> </figure> </swiper-slide> </swiper-container> <p>Of all machined components, the part that differs the most from the original concept is the player base, due to the complexity of the first iteration. The finalized geometry reflects a simpler design based on the amount of time available to complete the machining and the resources and machines available. Because of how each individual component meticulously interfaces, system-level assembly was especially important. Precision was emphasized as the assembly phase began, where threaded inserts were carefully installed to ensure the walls, base, and player rods connected as desired. Bushings were ordered from McMaster-Carr so that the rods could translate with little friction in the side walls.</p> <swiper-container class="media-swiper" keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/wall-player-assembly-480.webp 480w,/assets/img/wall-player-assembly-800.webp 800w,/assets/img/wall-player-assembly-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/wall-player-assembly.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/wall-bushings-480.webp 480w,/assets/img/wall-bushings-800.webp 800w,/assets/img/wall-bushings-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/wall-bushings.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/final-assembly-480.webp 480w,/assets/img/final-assembly-800.webp 800w,/assets/img/final-assembly-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/final-assembly.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> <p>For the most part, the mini foosball table functions as desired. However, due to the changes in the player model geometries from CAD to real life, there is slight unwanted contact that occurs between players of consecutive rods, which can significantly affect performance.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Design, manufacturing, and assembly of a scaled-down foosball table]]></summary></entry></feed>